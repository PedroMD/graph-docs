---
title: Quick and Easy Subgraph Debugging Using Forks
---

बर्‍याच प्रणाली मोठ्या प्रमाणात डेटावर प्रक्रिया करतात त्याप्रमाणे, ग्राफचे इंडेक्सर्स (ग्राफ नोड्स) लक्ष्य ब्लॉकचेनसह तुमचा सबग्राफ समक्रमित करण्यासाठी थोडा वेळ लागू शकतात. डीबगिंगच्या उद्देशाने झटपट बदल आणि इंडेक्सिंगसाठी आवश्यक असलेली दीर्घ प्रतीक्षा वेळ यांच्यातील तफावत अत्यंत प्रतिकूल आहे आणि आम्हाला याची चांगली जाणीव आहे. म्हणूनच आम्ही **सबग्राफ फोर्किंग** सादर करत आहोत, जे [LimeChain](https://limechain.tech/) ने विकसित केले आहे आणि या लेखात मी तुम्हाला हे वैशिष्ट्य दाखवणार आहे की हे वैशिष्ट्य सबग्राफ डीबगिंगचा वेग वाढवण्यासाठी कसा वापरला जाऊ शकतो!

## Ok, what is it?

**सबग्राफ फोर्किंग** ही _दुसऱ्या_ सबग्राफच्या स्टोअरमधून (सामान्यत: रिमोट एक) घटक आणण्याची प्रक्रिया आहे.

डीबगिंगच्या संदर्भात, **सबग्राफ फोर्किंग** तुम्हाला तुमचा अयशस्वी सबग्राफ ब्लॉक _X_ येथे वाट न पाहता डीबग करण्याची अनुमती देते _X_ ला ब्लॉक करण्यासाठी सिंक-अप करण्यासाठी.

## What?! How?

जेव्हा तुम्ही इंडेक्सिंगसाठी रिमोट ग्राफ नोडवर सबग्राफ उपयोजित करता आणि तो ब्लॉक _X_ वर अयशस्वी होतो, तेव्हा चांगली बातमी अशी आहे की आलेख नोड अजूनही त्याचे स्टोअर वापरून GraphQL क्वेरी सर्व्ह करेल, जे _X_ अवरोधित करण्यासाठी समक्रमित केले आहे. खूप छान आहे! याचा अर्थ ब्लॉक _X_ अनुक्रमित करताना उद्भवणाऱ्या बगचे निराकरण करण्यासाठी आम्ही या "अप-टू-डेट" स्टोअरचा लाभ घेऊ शकतो.

थोडक्यात, आम्ही एका रिमोट ग्राफ नोडवरून _अयशस्वी सबग्राफ फोर्क करणार आहोत_ ज्याला *X* ब्लॉक _X_ वर डीबग केलेला स्थानिकरित्या उपयोजित सबग्राफ प्रदान करण्यासाठी अनुक्रमणिका स्थितीचे अद्ययावत दृश्य.

## Please, show me some code!

To stay focused on subgraph debugging, let's keep things simple and run along with the [example-subgraph](https://github.com/graphprotocol/graph-tooling/tree/main/examples/ethereum-gravatar) indexing the Ethereum Gravity smart contract.

Here are the handlers defined for indexing `Gravatar`s, with no bugs whatsoever:

```tsx
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex().toString())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let gravatar = Gravatar.load(event.params.id.toI32().toString())
  if (gravatar == null) {
    log.critical('Gravatar not found!', [])
    return
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

अरेरे, किती दुर्दैवी आहे, जेव्हा मी माझा परिपूर्ण दिसणारा सबग्राफ [होस्टेड सर्व्हिस](https://thegraph.com/hosted-service/) वर तैनात करतो तेव्हा तो *"Gravatar आढळले नाही!"* त्रुटी.

The usual way to attempt a fix is:

1. Make a change in the mappings source, which you believe will solve the issue (while I know it won't).
2. Re-deploy the subgraph to the [Hosted Service](https://thegraph.com/hosted-service/) (or another remote Graph node).
3. Wait for it to sync-up.
4. If it breaks again go back to 1, otherwise: Hooray!

सामान्य डीबग प्रक्रियेसाठी हे खरोखरच परिचित आहे, परंतु एक पायरी आहे जी प्रक्रिया अत्यंत मंद करते: _3. ते समक्रमित होण्याची प्रतीक्षा करा._

Using **subgraph forking** we can essentially eliminate this step. Here is how it looks:

0. Spin-up a local Graph node with the **_appropriate fork-base_** set.
1. Make a change in the mappings source, which you believe will solve the issue.
2. Deploy to the local Graph node, **_forking the failing subgraph_** and **_starting from the problematic block_**.
3. If it breaks again, go back to 1, otherwise: Hooray!

Now, you may have 2 questions:

1. fork-base what???
2. Forking who?!

And I answer:

1. `fork-base` is the "base" URL, such that when the _subgraph id_ is appended the resulting URL (`<fork-base>/<subgraph-id>`) is a valid GraphQL endpoint for the subgraph's store.
2. Forking is easy, no need to sweat:

```bash
$ graph deploy <subgraph-name> --debug-fork <subgraph-id> --ipfs http://localhost:5001 --node http://localhost:8020
```

तसेच, सबग्राफ मॅनिफेस्टमधील `dataSources.source.startBlock` फील्ड समस्याग्रस्त ब्लॉकच्या संख्येवर सेट करण्यास विसरू नका, जेणेकरून तुम्ही अनावश्यक ब्लॉक्सची अनुक्रमणिका वगळू शकता आणि फोर्कचा फायदा घेऊ शकता!

So, here is what I do:

0. मी स्थानिक आलेख नोड स्पिन-अप करतो ([हे कसे करायचे ते येथे आहे](https://github.com/graphprotocol/graph-node#running-a-local-graph-node)) `फोर्क-बेस` पर्याय यावर सेट केला आहे: `https://api.thegraph.com/subgraphs/id/`, कारण मी सबग्राफ फोर्क करीन, मी तैनात केलेली बग्गी पूर्वी, [HostedService](https://thegraph.com/hosted-service/) वरून.

```
$ cargo run -p graph-node --release -- \
    --postgres-url postgresql://USERNAME[:PASSWORD]@localhost:5432/graph-node \
    --ethereum-rpc NETWORK_NAME:[CAPABILITIES]:URL \
    --ipfs 127.0.0.1:5001
    --fork-base https://api.thegraph.com/subgraphs/id/
```

1. After careful inspection I notice that there is a mismatch in the `id` representations used when indexing `Gravatar`s in my two handlers. While `handleNewGravatar` converts it to a hex (`event.params.id.toHex()`), `handleUpdatedGravatar` uses an int32 (`event.params.id.toI32()`) which causes the `handleUpdatedGravatar` to panic with "Gravatar not found!". I make them both convert the `id` to a hex.
2. After I made the changes I deploy my subgraph to the local Graph node, **_forking the failing subgraph_** and setting `dataSources.source.startBlock` to `6190343` in `subgraph.yaml`:

```bash
$ graph deploy gravity --debug-fork QmNp169tKvomnH3cPXTfGg4ZEhAHA6kEq5oy1XDqAxqHmW --ipfs http://localhost:5001 --node http://localhost:8020
```

3. I inspect the logs produced by the local Graph node and, Hooray!, everything seems to be working.
4. I deploy my now bug-free subgraph to a remote Graph node and live happily ever after! (no potatoes tho)
5. The end...
