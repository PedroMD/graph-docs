---
title: AssemblyScript API
---

> टीप: तुम्ही `graph-cli`/`graph-ts` आवृत्ती `0.22.0` पूर्वी सबग्राफ तयार केल्यास, तुम्ही ची जुनी आवृत्ती वापरत आहात असेंबलीस्क्रिप्ट, आम्ही [`स्थलांतर मार्गदर्शक`](/release-notes/assemblyscript-migration-guide) पाहण्याची शिफारस करतो

सबग्राफ मॅपिंग लिहिताना कोणते अंगभूत API वापरले जाऊ शकतात हे हे पृष्ठ दस्तऐवजीकरण करते. बॉक्सच्या बाहेर दोन प्रकारचे API उपलब्ध आहेत:

- the [Graph TypeScript library](https://github.com/graphprotocol/graph-ts) (`graph-ts`) and
- code generated from subgraph files by `graph codegen`.

जोपर्यंत ते [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) शी सुसंगत आहेत तोपर्यंत इतर लायब्ररी अवलंबित्व म्हणून जोडणे देखील शक्य आहे. या भाषेत मॅपिंग लिहिलेले असल्याने, [AssemblyScript विकी](https://github.com/AssemblyScript/assemblyscript/wiki) भाषा आणि मानक लायब्ररी वैशिष्ट्यांसाठी एक चांगला स्रोत आहे.

## Installation

[`graph init`](/developing/creating-a-subgraph) सह तयार केलेले सबग्राफ पूर्व-कॉन्फिगर केलेल्या अवलंबनांसह येतात. ही अवलंबित्वे स्थापित करण्यासाठी फक्त खालीलपैकी एक आज्ञा चालवणे आवश्यक आहे:

```sh
yarn install # Yarn
npm install  # NPM
```

If the subgraph was created from scratch, one of the following two commands will install the Graph TypeScript library as a dependency:

```sh
yarn add --dev @graphprotocol/graph-ts         # Yarn
npm install --save-dev @graphprotocol/graph-ts # NPM
```

## API Reference

The `@graphprotocol/graph-ts` library provides the following APIs:

- An `ethereum` API for working with Ethereum smart contracts, events, blocks, transactions, and Ethereum values.
- A `store` API to load and save entities from and to the Graph Node store.
- A `log` API to log messages to the Graph Node output and the Graph Explorer.
- An `ipfs` API to load files from IPFS.
- A `json` API to parse JSON data.
- A `crypto` API to use cryptographic functions.
- Low-level primitives to translate between different type systems such as Ethereum, JSON, GraphQL and AssemblyScript.

### Versions

सबग्राफ मॅनिफेस्टमधील `apiVersion` मॅपिंग API आवृत्ती निर्दिष्ट करते जी दिलेल्या सबग्राफसाठी ग्राफ नोडद्वारे चालविली जाते. वर्तमान मॅपिंग API आवृत्ती 0.0.6 आहे.

| Version | Release notes                                                                                                                                                                                                                                                               |
|:-------:| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  0.0.7  | Added `TransactionReceipt` and `Log` classes to the Ethereum types<br />Added `receipt` field to the Ethereum Event object                                                                                                                                            |
|  0.0.6  | Added `nonce` field to the Ethereum Transaction object<br />Added `baseFeePerGas` to the Ethereum Block object                                                                                                                                                        |
|  0.0.5  | असेंबलीस्क्रिप्ट आवृत्ती 0.19.10 वर श्रेणीसुधारित केली (यामध्ये ब्रेकिंग बदलांचा समावेश आहे, कृपया [`स्थलांतर मार्गदर्शक`](/release-notes/assemblyscript-migration-guide) पहा)<br />`ethereum.transaction.gasUsed` पुनर्नामित केले `ethereum.transaction.gasLimit` वर |
|  0.0.4  | Added `functionSignature` field to the Ethereum SmartContractCall object                                                                                                                                                                                                    |
|  0.0.3  | Added `from` field to the Ethereum Call object<br />`etherem.call.address` renamed to `ethereum.call.to`                                                                                                                                                              |
|  0.0.2  | Added `input` field to the Ethereum Transaction object                                                                                                                                                                                                                      |

### Built-in Types

Documentation on the base types built into AssemblyScript can be found in the [AssemblyScript wiki](https://github.com/AssemblyScript/assemblyscript/wiki/Types).

The following additional types are provided by `@graphprotocol/graph-ts`.

#### ByteArray

```typescript
import { ByteArray } from '@graphprotocol/graph-ts'
```

`ByteArray` represents an array of `u8`.

_Construction_

- `fromI32(x: i32): ByteArray` - Decomposes `x` into bytes.
- `fromHexString(hex: string): ByteArray` - Input length must be even. Prefixing with `0x` is optional.

_Type conversions_

- `toHexString(): string` - Converts to a hex string prefixed with `0x`.
- `toString(): string` - Interprets the bytes as a UTF-8 string.
- `toBase58(): string` - Encodes the bytes into a base58 string.
- `toU32(): u32` - Interprets the bytes as a little-endian `u32`. Throws in case of overflow.
- `toI32(): i32` - Interprets the byte array as a little-endian `i32`. Throws in case of overflow.

_Operators_

- `equals(y: ByteArray): bool` – can be written as `x == y`.
- `concat(other: ByteArray) : ByteArray` - return a new `ByteArray` consisting of `this` directly followed by `other`
- `concatI32(other: i32) : ByteArray` - return a new `ByteArray` consisting of `this` directly followed by the byte representation of `other`

#### BigDecimal

```typescript
import { BigDecimal } from '@graphprotocol/graph-ts'
```

`BigDecimal` is used to represent arbitrary precision decimals.

> टीप: [आंतरीक](https://github.com/graphprotocol/graph-node/blob/master/graph/src/data/store/scalar.rs) `BigDecimal` [IEEE-754 decimal128 फ्लोटिंग-पॉइंट फॉरमॅट](https://en.wikipedia.org/wiki/Decimal128_floating-point_format) मध्ये संग्रहित आहे, जे 34 दशांश अंकांना सपोर्ट करते. हे `BigDecimal` स्थिर-बिंदू प्रकारांचे प्रतिनिधित्व करण्यासाठी अनुपयुक्त बनवते जे 34 अंकांपेक्षा विस्तृत असू शकतात, जसे की सॉलिडिटी [`ufixed256x18`](https://docs.soliditylang.org/en/latest/types.html#fixed-point-numbers) किंवा समतुल्य.

_Construction_

- `constructor(bigInt: BigInt)` – creates a `BigDecimal` from an `BigInt`.
- `static fromString(s: string): BigDecimal` – parses from a decimal string.

_Type conversions_

- `toString(): string` – prints to a decimal string.

_Math_

- `plus(y: BigDecimal): BigDecimal` – can be written as `x + y`.
- `minus(y: BigDecimal): BigDecimal` – can be written as `x - y`.
- `times(y: BigDecimal): BigDecimal` – can be written as `x * y`.
- `div(y: BigDecimal): BigDecimal` – can be written as `x / y`.
- `equals(y: BigDecimal): bool` – can be written as `x == y`.
- `notEqual(y: BigDecimal): bool` – can be written as `x != y`.
- `lt(y: BigDecimal): bool` – can be written as `x < y`.
- `le(y: BigDecimal): bool` – can be written as `x <= y`.
- `gt(y: BigDecimal): bool` – can be written as `x > y`.
- `ge(y: BigDecimal): bool` – can be written as `x >= y`.
- `neg(): BigDecimal` - can be written as `-x`.

#### BigInt

```typescript
import { BigInt } from '@graphprotocol/graph-ts'
```

`BigInt` मोठ्या पूर्णांकांचे प्रतिनिधित्व करण्यासाठी वापरले जाते. यामध्ये `uint32` ते `uint256` आणि `int64` ते `int256` प्रकारातील इथरियम मूल्यांचा समावेश आहे. `uint32` खाली सर्व काही, जसे की `int32`, `uint24` किंवा `int8` `i32` म्हणून प्रस्तुत केले जाते.

The `BigInt` class has the following API:

_Construction_

- `BigInt.fromI32(x: i32): BigInt` – creates a `BigInt` from an `i32`.
- `BigInt.fromString(s: string): BigInt`– Parses a `BigInt` from a string.
- `BigInt.fromUnsignedBytes(x: Bytes): BigInt` – `बाइट्स` ला स्वाक्षरी न केलेले, लिटल-एंडियन पूर्णांक म्हणून व्याख्या करते. तुमचे इनपुट मोठे-एंडियन असल्यास, प्रथम `.reverse()` वर कॉल करा.
- `BigInt.fromSignedBytes(x: Bytes): BigInt` – `bytes` ला स्वाक्षरी केलेले, लिटल-एंडियन पूर्णांक म्हणून अर्थ लावतो. तुमचे इनपुट मोठे-एंडियन असल्यास, प्रथम `.reverse()` वर कॉल करा.

  _Type conversions_

- `x.toHex(): string` – turns `BigInt` into a string of hexadecimal characters.
- `x.toString(): string` – turns `BigInt` into a decimal number string.
- `x.toI32(): i32` – returns the `BigInt` as an `i32`; fails if the value does not fit into `i32`. It's a good idea to first check `x.isI32()`.
- `x.toBigDecimal(): BigDecimal` - converts into a decimal with no fractional part.

_Math_

- `x.plus(y: BigInt): BigInt` – can be written as `x + y`.
- `x.minus(y: BigInt): BigInt` – can be written as `x - y`.
- `x.times(y: BigInt): BigInt` – can be written as `x * y`.
- `x.div(y: BigInt): BigInt` – can be written as `x / y`.
- `x.mod(y: BigInt): BigInt` – can be written as `x % y`.
- `x.equals(y: BigInt): bool` – can be written as `x == y`.
- `x.notEqual(y: BigInt): bool` – can be written as `x != y`.
- `x.lt(y: BigInt): bool` – can be written as `x < y`.
- `x.le(y: BigInt): bool` – can be written as `x <= y`.
- `x.gt(y: BigInt): bool` – can be written as `x > y`.
- `x.ge(y: BigInt): bool` – can be written as `x >= y`.
- `x.neg(): BigInt` – can be written as `-x`.
- `x.divDecimal(y: BigDecimal): BigDecimal` – divides by a decimal, giving a decimal result.
- `x.isZero(): bool` – Convenience for checking if the number is zero.
- `x.isI32(): bool` – Check if the number fits in an `i32`.
- `x.abs(): BigInt` – Absolute value.
- `x.pow(exp: u8): BigInt` – Exponentiation.
- `bitOr(x: BigInt, y: BigInt): BigInt` – can be written as `x | y`.
- `bitAnd(x: BigInt, y: BigInt): BigInt` – can be written as `x & y`.
- `leftShift(x: BigInt, bits: u8): BigInt` – can be written as `x << y`.
- `rightShift(x: BigInt, bits: u8): BigInt` – can be written as `x >> y`.

#### TypedMap

```typescript
import { TypedMap } from '@graphprotocol/graph-ts'
```

`TypedMap` can be used to store key-value pairs. See [this example](https://github.com/graphprotocol/aragon-subgraph/blob/29dd38680c5e5104d9fdc2f90e740298c67e4a31/individual-dao-subgraph/mappings/constants.ts#L51).

The `TypedMap` class has the following API:

- `new TypedMap<K, V>()` – creates an empty map with keys of type `K` and values of type `T`
- `map.set(key: K, value: V): void` – sets the value of `key` to `value`
- `map.getEntry(की: K): TypedMapEntry<K, V> | शून्य` – `की` किंवा `नल` नकाशामध्ये `की` अस्तित्वात नसल्यास की-व्हॅल्यू जोडी परत करते
- `map.get(key: K): V | null` – returns the value for a `key` or `null` if the `key` does not exist in the map
- `map.isSet(key: K): bool` – returns `true` if the `key` exists in the map and `false` if it does not

#### Bytes

```typescript
import { Bytes } from '@graphprotocol/graph-ts'
```

`बाइट्स` चा वापर बाइट्सच्या अनियंत्रित-लांबीच्या अॅरेचे प्रतिनिधित्व करण्यासाठी केला जातो. यामध्ये `bytes`, `bytes32`, इत्यादी प्रकारची इथरियम मूल्ये समाविष्ट आहेत.

The `Bytes` class extends AssemblyScript's [Uint8Array](https://github.com/AssemblyScript/assemblyscript/blob/3b1852bc376ae799d9ebca888e6413afac7b572f/std/assembly/typedarray.ts#L64) and this supports all the `Uint8Array` functionality, plus the following new methods:

_Construction_

- `fromHexString(hex: string) : Bytes` - Convert the string `hex` which must consist of an even number of hexadecimal digits to a `ByteArray`. The string `hex` can optionally start with `0x`
- `fromI32(i: i32) : Bytes` - Convert `i` to an array of bytes

_Type conversions_

- `b.toHex()` – returns a hexadecimal string representing the bytes in the array
- `b.toString()` – converts the bytes in the array to a string of unicode characters
- `b.toBase58()` – turns an Ethereum Bytes value to base58 encoding (used for IPFS hashes)

_Operators_

- `b.concat(other: Bytes) : Bytes` - - return new `Bytes` consisting of `this` directly followed by `other`
- `b.concatI32(other: i32) : ByteArray` - return new `Bytes` consisting of `this` directly follow by the byte representation of `other`

#### Address

```typescript
import { Address } from '@graphprotocol/graph-ts'
```

`Address` extends `Bytes` to represent Ethereum `address` values.

It adds the following method on top of the `Bytes` API:

- `Address.fromString(s: string): Address` – creates an `Address` from a hexadecimal string
- `Address.fromBytes(b: Bytes): Address` – create an `Address` from `b` which must be exactly 20 bytes long. Passing in a value with fewer or more bytes will result in an error

### Store API

```typescript
import { store } from '@graphprotocol/graph-ts'
```

The `store` API allows to load, save and remove entities from and to the Graph Node store.

Entities written to the store map one-to-one to the `@entity` types defined in the subgraph's GraphQL schema. To make working with these entities convenient, the `graph codegen` command provided by the [Graph CLI](https://github.com/graphprotocol/graph-cli) generates entity classes, which are subclasses of the built-in `Entity` type, with property getters and setters for the fields in the schema as well as methods to load and save these entities.

#### Creating entities

The following is a common pattern for creating entities from Ethereum events.

```typescript
// Import the Transfer event class generated from the ERC20 ABI
import { Transfer as TransferEvent } from '../generated/ERC20/ERC20'

// Import the Transfer entity type generated from the GraphQL schema
import { Transfer } from '../generated/schema'

// Transfer event handler
export function handleTransfer(event: TransferEvent): void {
  // Create a Transfer entity, using the transaction hash as the entity ID
  let id = event.transaction.hash
  let transfer = new Transfer(id)

  // Set properties on the entity, using the event parameters
  transfer.from = event.params.from
  transfer.to = event.params.to
  transfer.amount = event.params.amount

  // Save the entity to the store
  transfer.save()
}
```

साखळीवर प्रक्रिया करत असताना जेव्हा `हस्तांतरण` इव्हेंट समोर येतो, तेव्हा तो जनरेट केलेला `हस्तांतरण` प्रकार वापरून `हँडल ट्रान्सफर` इव्हेंट हँडलरकडे पाठवला जातो (<code या नावाचे नाव >स्थानांतरण इव्हेंट</code> येथे अस्तित्व प्रकारासह नामकरण विरोध टाळण्यासाठी). हा प्रकार इव्हेंटचा पालक व्यवहार आणि त्याचे पॅरामीटर्स यासारख्या डेटामध्ये प्रवेश करण्याची परवानगी देतो.

इतर घटकांशी टक्कर टाळण्यासाठी प्रत्येक घटकाकडे एक अद्वितीय आयडी असणे आवश्यक आहे. इव्हेंट पॅरामीटर्समध्ये वापरला जाऊ शकणारा एक अद्वितीय अभिज्ञापक समाविष्ट करणे सामान्य आहे. टीप: आयडी म्हणून ट्रान्झॅक्शन हॅश वापरणे हे गृहित धरते की समान व्यवहारातील इतर कोणत्याही इव्हेंटमध्ये या हॅशसह आयडी म्हणून अस्तित्व निर्माण होत नाही.

#### Loading entities from the store

If an entity already exists, it can be loaded from the store with the following:

```typescript
let id = event.transaction.hash // or however the ID is constructed
let transfer = Transfer.load(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Use the Transfer entity as before
```

अद्याप स्टोअरमध्ये अस्तित्व नसल्यामुळे, `लोड` पद्धत `हस्तांतरण | शून्य`. त्यामुळे मूल्य वापरण्यापूर्वी `null` केस तपासणे आवश्यक असू शकते.

> **टीप:** मॅपिंगमध्ये केलेले बदल एखाद्या घटकाच्या मागील डेटावर अवलंबून असल्यासच घटक लोड करणे आवश्यक आहे. विद्यमान घटक अद्यतनित करण्याच्या दोन मार्गांसाठी पुढील विभाग पहा.

#### Looking up entities created withing a block

As of `graph-node` v0.31.0, `@graphprotocol/graph-ts` v0.30.0 and `@graphprotocol/graph-cli` v0.49.0 the `loadInBlock` method is available on all entity types.

The store API facilitates the retrieval of entities that were created or updated in the current block. A typical situation for this is that one handler creates a Transaction from some on-chain event, and a later handler wants to access this transaction if it exists. In the case where the transaction does not exist, the subgraph will have to go to the database just to find out that the entity does not exist; if the subgraph author already knows that the entity must have been created in the same block, using loadInBlock avoids this database roundtrip. For some subgraphs, these missed lookups can contribute significantly to the indexing time.

```typescript
let id = event.transaction.hash // or however the ID is constructed
let transfer = Transfer.loadInBlock(id)
if (transfer == null) {
  transfer = new Transfer(id)
}

// Use the Transfer entity as before
```

> Note: If there is no entity created in the given block, `loadInBlock` will return `null` even if there is an entity with the given ID in the store.

#### Updating existing entities

There are two ways to update an existing entity:

1. Load the entity with e.g. `Transfer.load(id)`, set properties on the entity, then `.save()` it back to the store.
2. फक्त यासह अस्तित्व तयार करा उदा. `नवीन हस्तांतरण(आयडी)`, घटकावर गुणधर्म सेट करा, नंतर ते स्टोअरमध्ये `.सेव्ह()` करा. अस्तित्व आधीच अस्तित्वात असल्यास, बदल त्यात विलीन केले जातात.

Changing properties is straight forward in most cases, thanks to the generated property setters:

```typescript
let transfer = new Transfer(id)
transfer.from = ...
transfer.to = ...
transfer.amount = ...
```

It is also possible to unset properties with one of the following two instructions:

```typescript
transfer.from.unset()
transfer.from = null
```

हे फक्त पर्यायी गुणधर्मांसह कार्य करते, म्हणजेच ग्राफक्यूएलमध्ये `!` शिवाय घोषित केलेले गुणधर्म. दोन उदाहरणे `मालक: बाइट्स` किंवा `रक्कम: BigInt` असतील.

अॅरे गुणधर्म अपडेट करणे थोडे अधिक गुंतलेले आहे, कारण एखाद्या घटकाकडून अॅरे मिळवणे त्या अॅरेची प्रत तयार करते. याचा अर्थ अॅरे बदलल्यानंतर अॅरे गुणधर्म पुन्हा स्पष्टपणे सेट करावे लागतील. खालील गृहीत धरते की `संख्या` मध्ये `संख्या: [BigInt!]!` फील्ड आहे.

```typescript
// This won't work
entity.numbers.push(BigInt.fromI32(1))
entity.save()

// This will work
let numbers = entity.numbers
numbers.push(BigInt.fromI32(1))
entity.numbers = numbers
entity.save()
```

#### Removing entities from the store

व्युत्पन्न केलेल्या प्रकारांद्वारे अस्तित्व काढून टाकण्याचा सध्या कोणताही मार्ग नाही. त्याऐवजी, एंटिटी काढून टाकण्यासाठी एंटिटी प्रकाराचे नाव आणि एंटिटी आयडी `store.remove` वर पास करणे आवश्यक आहे:

```typescript
import { store } from '@graphprotocol/graph-ts'
...
let id = event.transaction.hash
store.remove('Transfer', id)
```

### Ethereum API

Ethereum API स्मार्ट कॉन्ट्रॅक्ट्स, पब्लिक स्टेट व्हेरिएबल्स, कॉन्ट्रॅक्ट फंक्शन्स, इव्हेंट्स, व्यवहार, ब्लॉक्स आणि एन्कोडिंग/डिकोडिंग इथरियम डेटामध्ये प्रवेश प्रदान करते.

#### Support for Ethereum Types

घटकांप्रमाणे, `ग्राफ कोडजेन` सबग्राफमध्ये वापरल्या जाणार्‍या सर्व स्मार्ट करार आणि इव्हेंटसाठी वर्ग व्युत्पन्न करते. यासाठी, करार ABIs सबग्राफ मॅनिफेस्टमधील डेटा स्रोताचा भाग असणे आवश्यक आहे. सामान्यतः, ABI फाइल्स `abis/` फोल्डरमध्ये संग्रहित केल्या जातात.

व्युत्पन्न केलेल्या वर्गांसह, इथरियम प्रकार आणि [अंगभूत प्रकार](#built-in-types) मधील रूपांतरणे पडद्यामागे होतात जेणेकरून सबग्राफ लेखकांना त्यांच्याबद्दल काळजी करण्याची गरज नाही.

The following example illustrates this. Given a subgraph schema like

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
}
```

आणि Ethereum वर एक `Transfer(address,address,uint256)` इव्हेंट स्वाक्षरी, `पासून`, `ला` आणि `रक्कम` मूल्ये `पत्ता`, `पत्ता` आणि `uint256` प्रकार `Address` आणि `BigInt` मध्ये रूपांतरित केले जातात, परवानगी देऊन ते `Bytes!` आणि `BigInt!` गुणधर्मांना `Transfer` घटकाकडे पाठवले जातील:

```typescript
let id = event.transaction.hash
let transfer = new Transfer(id)
transfer.from = event.params.from
transfer.to = event.params.to
transfer.amount = event.params.amount
transfer.save()
```

#### Events and Block/Transaction Data

इथरियम इव्हेंट इव्हेंट हँडलर्सना पास केले जातात, जसे की मागील उदाहरणांमधील `Transfer` इव्हेंट, केवळ इव्हेंट पॅरामीटर्समध्येच प्रवेश प्रदान करत नाहीत तर त्यांच्या पालक व्यवहार आणि ते ज्या ब्लॉकचा भाग आहेत त्यामध्ये देखील प्रवेश प्रदान करतात. खालील डेटा `इव्हेंट` उदाहरणांमधून मिळू शकतो (हे वर्ग `graph-ts` मधील `ethereum` मॉड्यूलचा भाग आहेत):

```typescript
class Event {
  address: Address
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string | null
  block: Block
  transaction: Transaction
  parameters: Array<EventParam>
  receipt: TransactionReceipt | null
}

class Block {
  hash: Bytes
  parentHash: Bytes
  unclesHash: Bytes
  author: Address
  stateRoot: Bytes
  transactionsRoot: Bytes
  receiptsRoot: Bytes
  number: BigInt
  gasUsed: BigInt
  gasLimit: BigInt
  timestamp: BigInt
  difficulty: BigInt
  totalDifficulty: BigInt
  size: BigInt | null
  baseFeePerGas: BigInt | null
}

class Transaction {
  hash: Bytes
  index: BigInt
  from: Address
  to: Address | null
  value: BigInt
  gasLimit: BigInt
  gasPrice: BigInt
  input: Bytes
  nonce: BigInt
}

class TransactionReceipt {
  transactionHash: Bytes
  transactionIndex: BigInt
  blockHash: Bytes
  blockNumber: BigInt
  cumulativeGasUsed: BigInt
  gasUsed: BigInt
  contractAddress: Address
  logs: Array<Log>
  status: BigInt
  root: Bytes
  logsBloom: Bytes
}

class Log {
  address: Address
  topics: Array<Bytes>
  data: Bytes
  blockHash: Bytes
  blockNumber: Bytes
  transactionHash: Bytes
  transactionIndex: BigInt
  logIndex: BigInt
  transactionLogIndex: BigInt
  logType: string
  removed: bool | null
}
```

#### Access to Smart Contract State

`graph codegen` द्वारे व्युत्पन्न केलेल्या कोडमध्ये सबग्राफमध्ये वापरल्या जाणार्‍या स्मार्ट कॉन्ट्रॅक्टचे वर्ग देखील समाविष्ट आहेत. सध्याच्या ब्लॉकमध्ये सार्वजनिक स्टेट व्हेरिएबल्स आणि कॉन्ट्रॅक्टच्या कॉल फंक्शन्समध्ये प्रवेश करण्यासाठी याचा वापर केला जाऊ शकतो.

A common pattern is to access the contract from which an event originates. This is achieved with the following code:

```typescript
// Import the generated contract class and generated Transfer event class
import { ERC20Contract, Transfer as TransferEvent } from '../generated/ERC20Contract/ERC20Contract'
// Import the generated entity class
import { Transfer } from '../generated/schema'

export function handleTransfer(event: TransferEvent) {
  // Bind the contract to the address that emitted the event
  let contract = ERC20Contract.bind(event.address)

  // Access state variables and functions by calling them
  let erc20Symbol = contract.symbol()
}
```

`Transfer` is aliased to `TransferEvent` here to avoid a naming conflict with the entity type

जोपर्यंत Ethereum वरील `ERC20Contract` मध्ये `symbol` नावाचे सार्वजनिक वाचनीय फंक्शन आहे, तोपर्यंत त्याला `.symbol()` सह कॉल केले जाऊ शकते. पब्लिक स्टेट व्हेरिएबल्ससाठी समान नावाची पद्धत स्वयंचलितपणे तयार केली जाते.

Any other contract that is part of the subgraph can be imported from the generated code and can be bound to a valid address.

#### Handling Reverted Calls

जर तुमच्या कराराच्या केवळ-वाचनीय पद्धती परत येऊ शकतात, तर तुम्ही `प्रयत्न__` सह व्युत्पन्न केलेल्या करार पद्धतीला कॉल करून ते हाताळले पाहिजे. उदाहरणार्थ, गुरुत्वाकर्षण करार `gravatarToOwner` पद्धत उघड करतो. हा कोड त्या पद्धतीत रिव्हर्ट हाताळण्यास सक्षम असेल:

```typescript
let gravity = Gravity.bind(event.address)
let callResult = gravity.try_gravatarToOwner(gravatar)
if (callResult.reverted) {
  log.info('getGravatar reverted', [])
} else {
  let owner = callResult.value
}
```

लक्षात ठेवा की गेथ किंवा इन्फुरा क्लायंटशी कनेक्ट केलेला ग्राफ नोड सर्व रिव्हर्ट्स शोधू शकत नाही, जर तुम्ही यावर अवलंबून असाल तर आम्ही पॅरिटी क्लायंटशी कनेक्ट केलेला ग्राफ नोड वापरण्याची शिफारस करतो.

#### Encoding/Decoding ABI

Data can be encoded and decoded according to Ethereum's ABI encoding format using the `encode` and `decode` functions in the `ethereum` module.

```typescript
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let tupleArray: Array<ethereum.Value> = [
  ethereum.Value.fromAddress(Address.fromString('0x0000000000000000000000000000000000000420')),
  ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(62)),
]

let tuple = tupleArray as ethereum.Tuple

let encoded = ethereum.encode(ethereum.Value.fromTuple(tuple))!

let decoded = ethereum.decode('(address,uint256)', encoded)
```

For more information:

- [ABI Spec](https://docs.soliditylang.org/en/v0.7.4/abi-spec.html#types)
- Encoding/decoding [Rust library/CLI](https://github.com/rust-ethereum/ethabi)
- More [complex example](https://github.com/graphprotocol/graph-node/blob/6a7806cc465949ebb9e5b8269eeb763857797efc/tests/integration-tests/host-exports/src/mapping.ts#L72).

### Logging API

```typescript
import { log } from '@graphprotocol/graph-ts'
```

`लॉग` API सबग्राफना ग्राफ नोड मानक आउटपुट तसेच ग्राफ एक्सप्लोररवर माहिती लॉग करण्याची अनुमती देते. विविध लॉग स्तर वापरून संदेश लॉग केले जाऊ शकतात. वितर्कातून लॉग संदेश तयार करण्यासाठी मूलभूत स्वरूप स्ट्रिंग वाक्यरचना प्रदान केली जाते.

The `log` API includes the following functions:

- `log.debug(fmt: string, args: Array<string>): void` - logs a debug message.
- `log.info(fmt: string, args: Array<string>): void` - logs an informational message.
- `log.warning(fmt: string, args: Array<string>): void` - logs a warning.
- `log.error(fmt: string, args: Array<string>): void` - logs an error message.
- `log.critical(fmt: string, args: Array<string>): void` – logs a critical message _and_ terminates the subgraph.

`लॉग` API फॉरमॅट स्ट्रिंग आणि स्ट्रिंग व्हॅल्यूजचा अॅरे घेते. ते नंतर अॅरेमधील स्ट्रिंग व्हॅल्यूसह प्लेसहोल्डर बदलते. पहिला `{}` प्लेसहोल्डर अॅरेमधील पहिल्या व्हॅल्यूने बदलला जातो, दुसरा `{}` प्लेसहोल्डर दुसऱ्या व्हॅल्यूने बदलला जातो इ.

```typescript
log.info('Message to be displayed: {}, {}, {}', [value.toString(), anotherValue.toString(), 'already a string'])
```

#### Logging one or more values

##### Logging a single value

In the example below, the string value "A" is passed into an array to become`['A']` before being logged:

```typescript
let myValue = 'A'

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"
  log.info('My value is: {}', [myValue])
}
```

##### Logging a single entry from an existing array

In the example below, only the first value of the argument array is logged, despite the array containing three values.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My value is: A"  (Even though three values are passed to `log.info`)
  log.info('My value is: {}', myArray)
}
```

#### Logging multiple entries from an existing array

वितर्क अ‍ॅरेमधील प्रत्येक एंट्रीला लॉग मेसेज स्ट्रिंगमध्ये स्वतःचा प्लेसहोल्डर `{}` आवश्यक असतो. खालील उदाहरणामध्ये लॉग मेसेजमध्ये तीन प्लेसहोल्डर्स `{}` आहेत. यामुळे, `myArray` मधील तिन्ही मूल्ये लॉग केलेली आहेत.

```typescript
let myArray = ['A', 'B', 'C']

export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My first value is: A, second value is: B, third value is: C"
  log.info('My first value is: {}, second value is: {}, third value is: {}', myArray)
}
```

##### Logging a specific entry from an existing array

To display a specific value in the array, the indexed value must be provided.

```typescript
export function handleSomeEvent(event: SomeEvent): void {
  // Displays : "My third value is C"
  log.info('My third value is: {}', [myArray[2]])
}
```

##### Logging event information

The example below logs the block number, block hash and transaction hash from an event:

```typescript
import { log } from '@graphprotocol/graph-ts'

export function handleSomeEvent(event: SomeEvent): void {
  log.debug('Block number: {}, block hash: {}, transaction hash: {}', [
    event.block.number.toString(), // "47596000"
    event.block.hash.toHexString(), // "0x..."
    event.transaction.hash.toHexString(), // "0x..."
  ])
}
```

### IPFS API

```typescript
import { ipfs } from '@graphprotocol/graph-ts'
```

स्मार्ट कॉन्ट्रॅक्ट्स अधूनमधून IPFS फाइल्स चेनवर अँकर करतात. हे मॅपिंगला कॉन्ट्रॅक्टमधून IPFS हॅश प्राप्त करण्यास आणि IPFS मधील संबंधित फाइल्स वाचण्यास अनुमती देते. फाइल डेटा `बाइट्स` म्हणून परत केला जाईल, ज्यासाठी सहसा पुढील प्रक्रिया आवश्यक असते, उदा. या पृष्ठावर नंतर दस्तऐवजीकरण केलेल्या `json` API सह.

Given an IPFS hash or path, reading a file from IPFS is done as follows:

```typescript
// Put this inside an event handler in the mapping
let hash = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D'
let data = ipfs.cat(hash)

// Paths like `QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile`
// that include files in directories are also supported
let path = 'QmTkzDwWqPbnAh5YiV5VwcTLnGdwSNsNTn2aDxdXBFca7D/Makefile'
let data = ipfs.cat(path)
```

**टीप:** `ipfs.cat` याक्षणी निर्धारक नाही. विनंतीची वेळ संपण्यापूर्वी फाइल IPFS नेटवर्कवरून पुनर्प्राप्त केली जाऊ शकत नसल्यास, ती `null` परत करेल. यामुळे, `null` साठी परिणाम तपासणे नेहमीच फायदेशीर आहे.

`ipfs.map` सह स्ट्रीमिंग पद्धतीने मोठ्या फाइल्सवर प्रक्रिया करणे देखील शक्य आहे. फंक्शन IPFS फाईलसाठी हॅश किंवा पथ, कॉलबॅकचे नाव आणि त्याचे वर्तन सुधारण्यासाठी ध्वजांची अपेक्षा करते:

```typescript
import { JSONValue, Value } from '@graphprotocol/graph-ts'

export function processItem(value: JSONValue, userData: Value): void {
  // See the JSONValue documentation for details on dealing
  // with JSON values
  let obj = value.toObject()
  let id = obj.get('id')
  let title = obj.get('title')

  if (!id || !title) {
    return
  }

  // Callbacks can also created entities
  let newItem = new Item(id)
  newItem.title = title.toString()
  newitem.parent = userData.toString() // Set parent to "parentId"
  newitem.save()
}

// Put this inside an event handler in the mapping
ipfs.map('Qm...', 'processItem', Value.fromString('parentId'), ['json'])

// Alternatively, use `ipfs.mapJSON`
ipfs.mapJSON('Qm...', 'processItem', Value.fromString('parentId'))
```

सध्या समर्थित असलेला एकमेव ध्वज `json` आहे, जो `ipfs.map` ला पास करणे आवश्यक आहे. `json` ध्वजासह, IPFS फाइलमध्ये JSON मूल्यांची मालिका, प्रति ओळ एक मूल्य असणे आवश्यक आहे. `ipfs.map` ला केलेला कॉल फाइलमधील प्रत्येक ओळ वाचेल, ती `JSONValue` मध्ये डीसीरियलाइज करेल आणि त्या प्रत्येकासाठी कॉलबॅक कॉल करेल. कॉलबॅक नंतर `JSONValue` मधील डेटा संचयित करण्यासाठी अस्तित्व ऑपरेशन्स वापरू शकतो. `ipfs.map` नावाचा हँडलर यशस्वीरीत्या पूर्ण झाल्यावरच अस्तित्वातील बदल संचयित केले जातात; दरम्यान, ते मेमरीमध्ये ठेवले जातात, आणि `ipfs.map` प्रक्रिया करू शकतील अशा फाइलचा आकार मर्यादित आहे.

यश मिळाल्यावर, `ipfs.map` `void` परत करतो. कॉलबॅकच्या कोणत्याही आवाहनामुळे त्रुटी उद्भवल्यास, `ipfs.map` मागवणारा हँडलर रद्द केला जातो आणि सबग्राफ अयशस्वी म्हणून चिन्हांकित केला जातो.

### Crypto API

```typescript
import { crypto } from '@graphprotocol/graph-ts'
```

The `crypto` API makes a cryptographic functions available for use in mappings. Right now, there is only one:

- `crypto.keccak256(input: ByteArray): ByteArray`

### JSON API

```typescript
import { json, JSONValueKind } from '@graphprotocol/graph-ts'
```

JSON data can be parsed using the `json` API:

- `json.fromBytes(data: Bytes): JSONValue` – parses JSON data from a `Bytes` array interpreted as a valid UTF-8 sequence
- `json.try_fromBytes(डेटा: बाइट): परिणाम<JSONValue, boolean>` – `json.fromBytes` ची सुरक्षित आवृत्ती, पार्सिंग अयशस्वी झाल्यास ते त्रुटी प्रकार परत करते
- `json.fromString(data: string): JSONValue` – parses JSON data from a valid UTF-8 `String`
- `json.try_fromString(डेटा: स्ट्रिंग): परिणाम<JSONValue, boolean>` – `json.fromString` ची सुरक्षित आवृत्ती, पार्सिंग अयशस्वी झाल्यास ते त्रुटी प्रकार परत करते

`JSONValue` वर्ग अनियंत्रित JSON दस्तऐवजातून मूल्ये बाहेर काढण्याचा मार्ग प्रदान करतो. JSON मूल्ये बूलियन, संख्या, अॅरे आणि बरेच काही असू शकतात, `JSONValue` मूल्याचा प्रकार तपासण्यासाठी `प्रकार` गुणधर्मासह येतो:

```typescript
let value = json.fromBytes(...)
if (value.kind == JSONValueKind.BOOL) {
  ...
}
```

In addition, there is a method to check if the value is `null`:

- `value.isNull(): boolean`

When the type of a value is certain, it can be converted to a [built-in type](#built-in-types) using one of the following methods:

- `value.toBool(): boolean`
- `value.toI64(): i64`
- `value.toF64(): f64`
- `value.toBigInt(): BigInt`
- `value.toString(): string`
- `value.toArray(): Array<JSONValue>` - (and then convert `JSONValue` with one of the 5 methods above)

### Type Conversions Reference

| Source(s)            | Destination          | Conversion function          |
| -------------------- | -------------------- | ---------------------------- |
| Address              | Bytes                | none                         |
| Address              | String               | s.toHexString()              |
| BigDecimal           | String               | s.toString()                 |
| BigInt               | BigDecimal           | s.toBigDecimal()             |
| BigInt               | String (hexadecimal) | s.toHexString() or s.toHex() |
| BigInt               | String (unicode)     | s.toString()                 |
| BigInt               | i32                  | s.toI32()                    |
| Boolean              | Boolean              | none                         |
| Bytes (signed)       | BigInt               | BigInt.fromSignedBytes(s)    |
| Bytes (unsigned)     | BigInt               | BigInt.fromUnsignedBytes(s)  |
| Bytes                | String (hexadecimal) | s.toHexString() or s.toHex() |
| Bytes                | String (unicode)     | s.toString()                 |
| Bytes                | String (base58)      | s.toBase58()                 |
| Bytes                | i32                  | s.toI32()                    |
| Bytes                | u32                  | s.toU32()                    |
| Bytes                | JSON                 | json.fromBytes(s)            |
| int8                 | i32                  | none                         |
| int32                | i32                  | none                         |
| int32                | BigInt               | BigInt.fromI32(s)            |
| uint24               | i32                  | none                         |
| int64 - int256       | BigInt               | none                         |
| uint32 - uint256     | BigInt               | none                         |
| JSON                 | boolean              | s.toBool()                   |
| JSON                 | i64                  | s.toI64()                    |
| JSON                 | u64                  | s.toU64()                    |
| JSON                 | f64                  | s.toF64()                    |
| JSON                 | BigInt               | s.toBigInt()                 |
| JSON                 | string               | s.toString()                 |
| JSON                 | Array                | s.toArray()                  |
| JSON                 | Object               | s.toObject()                 |
| String               | Address              | Address.fromString(s)        |
| Bytes                | Address              | Address.fromBytes(s)         |
| String               | BigInt               | BigInt.fromString(s)         |
| String               | BigDecimal           | BigDecimal.fromString(s)     |
| String (hexadecimal) | Bytes                | ByteArray.fromHexString(s)   |
| String (UTF-8)       | Bytes                | ByteArray.fromUTF8(s)        |

### Data Source Metadata

तुम्ही `डेटास्रोत` नेमस्पेसद्वारे हँडलरला आमंत्रित केलेल्या डेटा स्रोताचा करार पत्ता, नेटवर्क आणि संदर्भ तपासू शकता:

- `dataSource.address(): Address`
- `dataSource.network(): string`
- `dataSource.context(): DataSourceContext`

### Entity and DataSourceContext

The base `Entity` class and the child `DataSourceContext` class have helpers to dynamically set and get fields:

- `setString(key: string, value: string): void`
- `setI32(key: string, value: i32): void`
- `setBigInt(key: string, value: BigInt): void`
- `setBytes(key: string, value: Bytes): void`
- `setBoolean(key: string, value: bool): void`
- `setBigDecimal(key, value: BigDecimal): void`
- `getString(key: string): string`
- `getI32(key: string): i32`
- `getBigInt(key: string): BigInt`
- `getBytes(key: string): Bytes`
- `getBoolean(key: string): boolean`
- `getBigDecimal(key: string): BigDecimal`

### Common AssemblyScript Issues

काही [AssemblyScript](https://github.com/AssemblyScript/assemblyscript) समस्या आहेत ज्या सबग्राफ डेव्हलपमेंट दरम्यान सामान्य आहेत. ते डीबग अडचणीत आहेत, तथापि, त्यांच्याबद्दल जागरूक असणे मदत करू शकते. या समस्यांची संपूर्ण यादी खाली दिली आहे:

- `खाजगी` वर्ग व्हेरिएबल्स [AssembyScript](https://www.assemblyscript.org/status.html#language-features) मध्ये लागू केले जात नाहीत. क्लास व्हेरिएबल्सना क्लास ऑब्जेक्टमधून थेट बदलण्यापासून संरक्षित करण्याचा कोणताही मार्ग नाही.
- व्याप्ती [क्लोजर फंक्शन्स](https://www.assemblyscript.org/status.html#on-closures) मध्ये वारशाने मिळत नाही, म्हणजे क्लोजर फंक्शन्सच्या बाहेर घोषित केलेले व्हेरिएबल्स वापरले जाऊ शकत नाहीत. [डेव्हलपर हायलाइट्स #3](https://www.youtube.com/watch?v=1-8AW-lVfrA&t=3243s) मध्ये स्पष्टीकरण.
