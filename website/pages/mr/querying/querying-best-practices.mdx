---
title: Querying Best Practices
---

The Graph provides a decentralized way to query data from blockchains.

ग्राफ नेटवर्कचा डेटा GraphQL API द्वारे उघड केला जातो, ज्यामुळे GraphQL भाषेसह डेटाची क्वेरी करणे सोपे होते.

हे पृष्‍ठ तुम्हाला GraphQL भाषेचे अत्यावश्यक नियम आणि GraphQL क्वेरी सर्वोत्तम पद्धतींबद्दल मार्गदर्शन करेल.

---

## Querying a GraphQL API

### The anatomy of a GraphQL query

REST API च्या विपरीत, GraphQL API एका स्कीमावर तयार केले जाते जे कोणत्या क्वेरी पूर्ण केल्या जाऊ शकतात हे परिभाषित करते.

For example, a query to get a token using the `token` query will look as follows:

```graphql
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
```

which will return the following predictable JSON response (_when passing the proper `$id` variable value_):

```json
{
  "token": {
    "id": "...",
    "owner": "..."
  }
}
```

GraphQL queries use the GraphQL language, which is defined upon [a specification](https://spec.graphql.org/).

The above `GetToken` query is composed of multiple language parts (replaced below with `[...]` placeholders):

```graphql
query [operationName]([variableName]: [variableType]) {
  [queryName]([argumentName]: [variableName]) {
    # "{ ... }" express a Selection-Set, we are querying fields from `queryName`.
    [field]
    [field]
  }
}
```

सिंटॅक्टिक करा आणि करू नका याची यादी लांब असताना, ग्राफक्यूएल क्वेरी लिहिताना लक्षात ठेवण्याचे आवश्यक नियम येथे आहेत:

- Each `queryName` must only be used once per operation.
- Each `field` must be used only once in a selection (we cannot query `id` twice under `token`)
- काही `फील्ड` किंवा क्वेरी (जसे की `टोकन्स`) जटिल प्रकार देतात ज्यांना उप-फील्डची निवड आवश्यक असते. अपेक्षित असताना निवड प्रदान न केल्याने (किंवा अपेक्षित नसताना एक प्रदान करणे - उदाहरणार्थ, `id` वर) त्रुटी वाढवेल. फील्ड प्रकार जाणून घेण्यासाठी, कृपया [द ग्राफ एक्सप्लोरर](/network/explorer) पहा.
- Any variable assigned to an argument must match its type.
- In a given list of variables, each of them must be unique.
- All defined variables must be used.

Failing to follow the above rules will end with an error from the Graph API.

For a complete list of rules with code examples, please look at our GraphQL Validations guide.

<br />

### Sending a query to a GraphQL API

GraphQL is a language and set of conventions that transport over HTTP.

It means that you can query a GraphQL API using standard `fetch` (natively or via `@whatwg-node/fetch` or `isomorphic-fetch`).

तथापि, ["अ‍ॅप्लिकेशनमधून क्वेरी करणे"](/querying/querying-from-an-application) मध्ये सांगितल्याप्रमाणे, आम्ही तुम्हाला आमचे `ग्राफ-क्लायंट` वापरण्याची शिफारस करतो जे अद्वितीय वैशिष्ट्यांना समर्थन देते जसे की:

- Cross-chain Subgraph Handling: Querying from multiple subgraphs in a single query
- [Automatic Block Tracking](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)
- [Automatic Pagination](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)
- Fully typed result

<br />

Here's how to query The Graph with `graph-client`:

```tsx
import { execute } from '../.graphclient'

const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`
const variables = { id: '1' }

async function main() {
  const result = await execute(query, variables)
  // `result` is fully typed!
  console.log(result)
}

main()
```

More GraphQL client alternatives are covered in ["Querying from an Application"](/querying/querying-from-an-application).

<br />

आता आम्ही GraphQL क्वेरी सिंटॅक्सचे मूलभूत नियम समाविष्ट केले आहेत, आता GraphQL क्वेरी लेखनाच्या सर्वोत्तम पद्धती पाहू.

---

## Writing GraphQL queries

### Always write static queries

A common (bad) practice is to dynamically build query strings as follows:

```tsx
const id = params.id
const fields = ['id', 'owner']
const query = `
query GetToken {
  token(id: ${id}) {
    ${fields.join('\n')}
  }
}
`

// Execute query...
```

While the above snippet produces a valid GraphQL query, **it has many drawbacks**:

- it makes it **harder to understand** the query as a whole
- developers are **responsible for safely sanitizing the string interpolation**
- विनंती पॅरामीटर्सचा भाग म्हणून व्हेरिएबल्सची मूल्ये पाठवत नाही **सर्व्हर-साइडवर संभाव्य कॅशिंग प्रतिबंधित करा**
- it **prevents tools from statically analyzing the query** (ex: Linter, or type generations tools)

For this reason, it is recommended to always write queries as static strings:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!) {
  token(id: $id) {
    id
    owner
  }
}
`

const result = await execute(query, {
  variables: {
    id,
  },
})
```

Doing so brings **many advantages**:

- **Easy to read and maintain** queries
- The GraphQL **server handles variables sanitization**
- **Variables can be cached** at server-level
- **Queries can be statically analyzed by tools** (more on this in the following sections)

**Note: How to include fields conditionally in static queries**

We might want to include the `owner` field only on a particular condition.

For this, we can leverage the `@include(if:...)` directive as follows:

```tsx
import { execute } from 'your-favorite-graphql-client'

const id = params.id
const query = `
query GetToken($id: ID!, $includeOwner: Boolean) {
  token(id: $id) {
    id
    owner @include(if: $includeOwner)
  }
}
`

const result = await execute(query, {
  variables: {
    id,
    includeOwner: true,
  },
})
```

Note: The opposite directive is `@skip(if: ...)`.

<br />

### Performance tips

**"Ask for what you want"**

GraphQL became famous for its "Ask for what you want" tagline.

For this reason, there is no way, in GraphQL, to get all available fields without having to list them individually.

When querying GraphQL APIs, always think of querying only the fields that will be actually used.

ओव्हर-फेचिंगचे एक सामान्य कारण म्हणजे घटकांचे संकलन. डीफॉल्टनुसार, क्वेरी संग्रहामध्ये 100 संस्था आणतील, जे सहसा वापरकर्त्याला दाखवण्यासाठी वापरल्या जाणार्‍या प्रत्यक्षात वापरल्या जाणार्‍या पेक्षा जास्त असते. त्यामुळे क्वेरी जवळजवळ नेहमीच प्रथम स्पष्टपणे सेट केल्या पाहिजेत आणि ते फक्त त्यांना आवश्यक तेवढ्याच संस्था आणतात याची खात्री करा. हे केवळ एका क्वेरीमधील उच्च-स्तरीय संग्रहांना लागू होत नाही, तर त्याहूनही अधिक घटकांच्या नेस्टेड संग्रहांना लागू होते.

For example, in the following query:

```graphql
query listTokens {
  tokens {
    # will fetch up to 100 tokens
    id
    transactions {
      # will fetch up to 100 transactions
      id
    }
  }
}
```

The response could contain 100 transactions for each of the 100 tokens.

ऍप्लिकेशनला फक्त 10 व्यवहारांची आवश्यकता असल्यास, क्वेरीने व्यवहार फील्डवर स्पष्टपणे `first: 10` सेट केले पाहिजे.

**Combining multiple queries**

Your application might require querying multiple types of data as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const tokensQuery = `
query GetTokens {
  tokens(first: 50) {
    id
    owner
  }
}
`
const countersQuery = `
query GetCounters {
  counters {
    id
    value
  }
}
`

const [tokens, counters] = Promise.all(
  [
    tokensQuery,
    countersQuery,
  ].map(execute)
)
```

While this implementation is totally valid, it will require two round trips with the GraphQL API.

Fortunately, it is also valid to send multiple queries in the same GraphQL request as follows:

```graphql
import { execute } from "your-favorite-graphql-client"

const query = `
query GetTokensandCounters {
  tokens(first: 50) {
    id
    owner
  }
  counters {
    id
    value
  }
}
`

const  { result: { tokens, counters } } = execute(query)
```

हा दृष्टिकोन नेटवर्कवर घालवलेला वेळ कमी करून **एकूण कार्यप्रदर्शन सुधारेल** आणि एक **अधिक संक्षिप्त अंमलबजावणी**.

<br />

### Leverage GraphQL Fragments

A helpful feature to write GraphQL queries is GraphQL Fragment.

Looking at the following query, you will notice that some fields are repeated across multiple Selection-Sets (`{ ... }`):

```graphql
query {
  bondEvents {
    id
    newDelegate {
      id
      active
      status
    }
    oldDelegate {
      id
      active
      status
    }
  }
}
```

Such repeated fields (`id`, `active`, `status`) bring many issues:

- harder to read for more extensive queries
- प्रश्नांवर आधारित TypeScript प्रकार व्युत्पन्न करणारी साधने वापरताना (_त्यावर शेवटच्या विभागात अधिक_), `newDelegate` आणि `oldDelegate` या दोन वेगळ्या इनलाइनचा परिणाम होईल इंटरफेस.

A refactored version of the query would be the following:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...DelegateItem
    }
    oldDelegate {
      ...DelegateItem
    }
  }
}

# we define a fragment (subtype) on Transcoder
# to factorize repeated fields in the query
fragment DelegateItem on Transcoder {
  id
  active
  status
}
```

GraphQL `fragment` वापरल्याने वाचनीयता (विशेषत: स्केलवर) सुधारेल परंतु TypeScript प्रकारांची निर्मिती देखील चांगली होईल.

प्रकार जनरेशन टूल वापरताना, वरील क्वेरी योग्य `DelegateItemFragment` प्रकार व्युत्पन्न करेल (_शेवटचा "साधने" विभाग पहा_).

<br />

### GraphQL Fragment do's and don'ts

**Fragment base must be a type**

A Fragment cannot be based on a non-applicable type, in short, **on type not having fields**:

```graphql
fragment MyFragment on BigInt {
  # ...
}
```

`BigInt` is a **scalar** (native "plain" type) that cannot be used as a fragment's base.

**How to spread a Fragment**

Fragments are defined on specific types and should be used accordingly in queries.

Example:

```graphql
query {
  bondEvents {
    id
    newDelegate {
      ...VoteItem # Error! `VoteItem` cannot be spread on `Transcoder` type
    }
    oldDelegate {
      ...VoteItem
    }
  }
}

fragment VoteItem on Vote {
  id
  voter
}
```

`newDelegate` and `oldDelegate` are of type `Transcoder`.

It is not possible to spread a fragment of type `Vote` here.

**Define Fragment as an atomic business unit of data**

GraphQL Fragment must be defined based on their usage.

बर्‍याच वापर-केससाठी, प्रति प्रकार एक तुकडा परिभाषित करणे (पुन्हा फील्ड वापरण्याच्या किंवा प्रकार निर्मितीच्या बाबतीत) पुरेसे आहे.

Here is a rule of thumb for using Fragment:

- when fields of the same type are repeated in a query, group them in a Fragment
- when similar but not the same fields are repeated, create multiple fragments, ex:

```graphql
# base fragment (mostly used in listing)
fragment Voter on Vote {
  id
  voter
}

# extended fragment (when querying a detailed view of a vote)
fragment VoteWithPoll on Vote {
  id
  voter
  choiceID
  poll {
    id
    proposal
  }
}
```

---

## The essential tools

### GraphQL web-based explorers

तुमच्या ऍप्लिकेशनमध्ये क्वेरी चालवून त्यावर पुनरावृत्ती करणे त्रासदायक असू शकते. या कारणास्तव, तुमच्‍या अॅप्लिकेशनमध्‍ये जोडण्‍यापूर्वी तुमच्‍या क्‍वेरींची चाचणी करण्‍यासाठी [The Graph Explorer](https://thegraph.com/explorer) वापरण्‍यास अजिबात संकोच करू नका. तुमच्या प्रश्नांची चाचणी घेण्यासाठी ग्राफ एक्सप्लोरर तुम्हाला पूर्व-कॉन्फिगर केलेले GraphQL खेळाचे मैदान देईल.

तुम्‍ही तुमच्‍या क्‍वेरी डीबग/चाचणी करण्‍याचा अधिक लवचिक मार्ग शोधत असल्‍यास, इतर समान वेब-आधारित साधने उपलब्‍ध आहेत जसे की [Altair](https://altair.sirmuel.design/) आणि [GrafiQL](https://graphiql-online.com/graphiql).

<br />

### GraphQL Linting

वर नमूद केलेल्या सर्वोत्तम पद्धती आणि वाक्यरचना नियमांचे पालन करण्यासाठी, खालील वर्कफ्लो आणि IDE टूल्स वापरण्याची अत्यंत शिफारस केली जाते.

**GraphQL ESLint**

[GraphQL ESLint](https://github.com/dotansimha/graphql-eslint) will help you stay on top of GraphQL best practices with zero effort.

[Setup the "operations-recommended"](https://github.com/dotansimha/graphql-eslint#available-configs) config will enforce essential rules such as:

- `@graphql-eslint/fields-on-correct-type`: is a field used on a proper type?
- `@graphql-eslint/no-unused variables`: should a given variable stay unused?
- and more!

This will allow you to **catch errors without even testing queries** on the playground or running them in production!

<br />

### IDE plugins

**VSCode and GraphQL**

The [GraphQL VSCode extension](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql) is an excellent addition to your development workflow to get:

- syntax highlighting
- autocomplete suggestions
- validation against schema
- snippets
- go to definition for fragments and input types

जर तुम्ही `graphql-eslint` वापरत असाल, तर तुमच्या कोडमध्ये इनलाइन केलेल्या त्रुटी आणि चेतावणी योग्यरित्या व्हिज्युअलायझ करण्यासाठी [ESLint VSCode विस्तार](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) असणे आवश्यक आहे.

**WebStorm/Intellij and GraphQL**

[JS GraphQL प्लगइन](https://plugins.jetbrains.com/plugin/8097-graphql/) प्रदान करून GraphQL सोबत काम करताना तुमच्या अनुभवामध्ये लक्षणीय सुधारणा करेल:

- syntax highlighting
- autocomplete suggestions
- validation against schema
- snippets

More information on this [WebStorm article](https://blog.jetbrains.com/webstorm/2019/04/featured-plugin-js-graphql/) that showcases all the plugin's main features.
